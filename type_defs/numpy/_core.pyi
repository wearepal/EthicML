"""
Numpy's mypy stub. Only type declarations for ndarray, the scalar hierarchy and array creation
methods are provided.
"""

from typing import (Any, Callable, Dict, Generic, Iterator, IO, List, Optional, Sequence, Tuple,
                    Type, TypeVar, Union)
from pathlib import Path

class dtype: ...
_dtype = dtype

_ShapeType = Union[int, Tuple[int, ...], List[int]]
_AxesType = Union[int, Tuple[int, ...], List[int]]
_OrderType = Union[str, Sequence[str]]
_DtypeType = Union[dtype, type]

# all the python types that an ndarray can have
_AnyNum = Union[int, float, bool]
# generic types that are only allowed to take on values from _AnyNum
_Num = TypeVar('_Num', int, float, bool)
_Num2 = TypeVar('_Num2', int, float, bool)

_T = TypeVar('_T')
NestedList = Union[List[_T], List[List[_T]], List[List[List[_T]]], List[List[List[List[_T]]]]]

class ndarray(Generic[_Num]):
    """
    "array-like" interface that both numpy.ndarray and all scalars (descendants of numpy.generic)
    implement this interface.
    """
    #
    # Array-like structures attributes
    #
    dtype: _dtype
    size: int
    ndim: int
    shape: Tuple[int, ...]

    #
    # Array-like methods
    #

    # Once this issue https://github.com/python/mypy/issues/1907 is resolved, most methods that
    # have an 'out' argument, will be implemented using overload instead of with a Union
    # result. mypy is smart enough to assign the proper type (_ArrayLike[_U]) when out is present
    # but it falls back to the union when it's not.
    def __init__(self, shape: Tuple[int, ...], dtype: _DtypeType=None,
                 buffer: Any=None, offset: int=None,
                 strides: Tuple[int, ...]=None, order: str=None) -> None: ...
    def all(self, axis: _AxesType = None,
            keepdims: bool=False) -> ndarray[_Num]: ...

    def any(self, axis: _AxesType=None,
            keepdims: bool=False) -> ndarray[_Num]: ...

    def argmax(self, axis: int=None) -> ndarray[_Num]: ...

    def argmin(self, axis: int=None) -> ndarray[_Num]: ...

    # def argpartition(self, kth: Union[int, Sequence[int]], axis: Optional[int]=-1,
    #                  kind: str='introselect', order: _OrderType=None) -> ndarray[_Num]: ...

    def argsort(self, axis: int=None, kind: str='quicksort',
                order: _OrderType=None) -> ndarray[_Num]: ...

    def astype(self, dtype: Any, order: str='K', casting: str='unsafe', subok: bool=True,
               copy: bool=False) -> ndarray[_Num]: ...

    def byteswap(self, inplace: bool=False) -> ndarray[_Num]: ...

    def choose(self, choices:Sequence[ndarray[_Num]], out: ndarray[_Num]=None,
               mode: str='raise') ->  Union[ndarray[_Num], ndarray[_Num]]: ...

    def clip(self, a_min: Any, a_max: Any,
             out: ndarray[_Num]=None) -> Union[ndarray[_Num], ndarray[_Num]]: ...

    def compress(self, condition: Sequence[bool], axis: int=None,
                 out: ndarray[_Num]=None) -> Union[ndarray[_Num], ndarray[_Num]]: ...

    def conj(self) -> ndarray[_Num]: ...

    def conjugate(self) -> ndarray[_Num]: ...

    def copy(self, order: str='C') -> ndarray[_Num]: ...

    def cumprod(self, axis: int=None, dtype: Any=None,
                out: ndarray[_Num]=None) -> ndarray[_Num]: ...

    def cumsum(self, axis: int=None, dtype: _DtypeType=None,
                out: ndarray[_Num]=None) -> ndarray[_Num]: ...

    def diagonal(self, offset: int=0, axis1: int=0, axis2: int=1) -> ndarray[_Num]: ...

    def dot(self, b: ndarray[_Num], out: ndarray[_Num]=None) -> ndarray[_Num]: ...

    def dump(self, file: str) -> None: ...

    def dumps(self) -> str: ...

    # def fill(self, value: _S) -> None: ...

    def flatten(self, order: str='C') -> ndarray[_Num]: ...

    def getfield(self, dtype: _DtypeType, offset: int=0) -> ndarray[_Num]: ...

    def item(self) -> _Num: ...

    def itemset(self, arg0: Union[int, Tuple[int, ...]], arg1: Any=None) -> None: ...

    def max(self) -> _Num: ...

    def mean(self) -> float: ...

    def min(self) -> _Num: ...

    def newbyteorder(self, new_order: str='S') -> ndarray[_Num]: ...

    def nonzero(self) -> ndarray[_Num]: ...

    def partition(self, kth: _AxesType, axis: int=-1, kind: str='introselect',
                  order: _OrderType=None) -> None: ...

    def prod(self, axis: _AxesType=None, dtype: _DtypeType=None,
             out: ndarray[_Num]=None, keepdims: bool=False) -> ndarray[_Num]: ...

    def ptp(self, axis: int=None,
            out: ndarray[_Num]=None) -> Union[ndarray[_Num], ndarray[_Num]]: ...

    def put(self, ind: ndarray[_Num], v: ndarray[_Num], mode: str='raise') -> None: ...

    def ravel(self, order: str='C') -> ndarray[_Num]: ...

    def repeat(self, repeats: Union[int, Sequence[int]],
               axis: int=None) -> ndarray[_Num]: ...

    def reshape(self, newshape: _ShapeType,
                order: str='C') -> ndarray[_Num]: ...

    def resize(self, new_shape: _ShapeType, refcheck: bool=True) -> None: ...

    def round(self, decimals: int=0,
              out: ndarray[_Num]=None) -> Union[ndarray[_Num], ndarray[_Num]]: ...

    # def searchsorted(self, v: Union[_S, ndarray[_Num]], side: str='left',
    #                  sorter: ndarray[_Num]=None) -> ndarray[_Num]: ...

    def setfield(self, val: Any, dtype: _DtypeType, offset: int=0) -> None: ...

    def setflags(self, write: bool=None, align: bool=None,
                 uic: bool=None) -> None: ...

    def sort(self, axis: int=-1, kind: str='quicksort', order: _OrderType=None) -> None: ...

    def squeeze(self, axis: _AxesType=None) -> ndarray[_Num]: ...

    def std(self, axis: _AxesType=None, dtype: _DtypeType=None,
            out: ndarray[_Num]=None, ddof: int=0, keepdims: bool=False) -> ndarray[_Num]: ...

    def sum(self) -> _Num: ...

    def swapaxes(self, axis1: int, axis2: int) -> ndarray[_Num]: ...

    def take(self, indices: Sequence[int], axis: int=None,
             out: ndarray[_Num]=None,
             mode: str='raise') -> Union[ndarray[_Num], ndarray[_Num]]: ...

    def tobytes(self, order: str='C') -> bytes: ...

    def tofile(self, fid: object, sep: str='',  # TODO fix fid definition (There's a bug in mypy io's namespace https://github.com/python/mypy/issues/1462)
               format: str='%s') -> None: ...

    def tolist(self) -> List: ...

    def tostring(self, order: str='C') -> bytes: ...

    def trace(self, offset: int=0, axis1: int=0, axis2: int=1,
              dtype: _DtypeType=None, out: ndarray[_Num]=None) -> ndarray[_Num]: ...

    def transpose(self, axes: _AxesType = None) -> ndarray[_Num]: ...

    def var(self, axis: _AxesType=None, dtype: _DtypeType=None,
            out: ndarray[_Num]=None, ddof: int=0, keepdims: bool=False) -> ndarray[_Num]: ...

    def view(self, dtype: Union[_DtypeType, Type['ndarray[_Num]']]=None,
             type: type=None) -> ndarray[_Num]: ...

    #
    # Magic methods
    #

    def __abs__(self) -> ndarray[_Num]: ...

    def __add__(self, value: object) -> ndarray[_Num]: ...

    def __and__(self, value: object) -> ndarray[_Num]: ...

    def __array__(self, dtype: _DtypeType=None) -> ndarray[_Num]: ...

    def __array_prepare__(self, context: object=None) -> ndarray[_Num]: ...

    def __array_wrap__(self, context: object=None) -> ndarray[_Num]: ...

    def __bool__(self) -> bool: ...

    def __complex__(self) -> complex: ...

    def __contains__(self, key: object) -> bool: ...

    def __copy__(self) -> ndarray[_Num]: ...

    def __deepcopy__(self) -> ndarray[_Num]: ...

    def __delattr__(self, name: str) -> None: ...

    def __delitem__(self, key: str) -> None: ...

    def __dir__(self) -> List[str]: ...

    def __divmod__(self, value: object) -> Tuple[ndarray[_Num], ndarray[_Num]]: ...

    def __eq__(self, value: object) -> ndarray[bool]: ...

    def __float__(self) -> float: ...

    def __floordiv__(self, value: object) -> ndarray[_Num]: ...

    def __ge__(self, value: object) -> ndarray[bool]: ...

    def __getattribute__(self, name: str) -> Any: ...

    def __getitem__(self, key: Any) -> _Num: ...

    def __gt__(self, value: object) -> ndarray[bool]: ...

    def __iadd__(self, value: object) -> None: ...

    def __iand__(self, value: object) -> None: ...

    def __ifloordiv__(self, value: object) -> None: ...

    def __ilshift__(self, value: object) -> None: ...

    def __imatmul__(self, value: ndarray[_Num]) -> None: ...

    def __imod__(self, value: object) -> None: ...

    def __imul__(self, value: object) -> None: ...

    def __index__(self) -> int: ...

    def __int__(self) -> int: ...

    def __invert__(self) -> ndarray[_Num]: ...

    def __ior__(self, value: object) -> None: ...

    def __ipow__(self, value: object) -> None: ...

    def __irshift__(self, value: object) -> None: ...

    def __isub__(self, value: object) -> None: ...

    def __iter__(self) -> Iterator[_Num]: ...

    def __itruediv__(sel, value: object) -> None: ...

    def __ixor__(self, value: object) -> None: ...

    def __le__(self, value: object) -> ndarray[_Num]: ...

    def __len__(self) -> int: ...

    def __lshift__(self, value: object) -> ndarray[_Num]: ...

    def __lt__(self, value: object) -> ndarray[_Num]: ...

    def __matmul__(self, value: ndarray[_Num]) -> ndarray[_Num]: ...

    def __mod__(self, value: object) -> ndarray[_Num]: ...

    def __mul__(self, value: object) -> ndarray[_Num]: ...

    def __ne__(self, value: object) -> ndarray[_Num]: ...  # type: ignore

    def __neg__(self) -> ndarray[_Num]: ...

    def __or__(self, value: object) -> ndarray[_Num]: ...

    def __pos__(self) -> ndarray[_Num]: ...

    def __pow__(self, value: object) -> ndarray[_Num]: ...

    def __radd__(self, value: object) -> ndarray[_Num]: ...

    def __rand__(self, value: object) -> ndarray[_Num]: ...

    def __rdivmod__(self, value: object) -> Tuple[ndarray[_Num], ndarray[_Num]]: ...

    def __rfloordiv__(self, value: object) -> ndarray[_Num]: ...

    def __rlshift__(self, value: object) -> ndarray[_Num]: ...

    def __rmatmul__(self, value: object) -> ndarray[_Num]: ...

    def __rmod__(self, value: object) -> ndarray[_Num]: ...

    def __rmul__(self, value: object) -> ndarray[_Num]: ...

    def __ror__(self, value: object) -> ndarray[_Num]: ...

    def __rpow__(self, value: object) -> ndarray[_Num]: ...

    def __rrshift__(self, value: object) -> ndarray[_Num]: ...

    def __rshift__(self, value: object) -> ndarray[_Num]: ...

    def __rsub__(self, value: object) -> ndarray[_Num]: ...

    def __rtruediv__(self, value: object) -> ndarray[_Num]: ...

    def __rxor__(self, value: object) -> ndarray[_Num]: ...

    def __setattr__(self, name: str, value: Any) -> None: ...

    def __setitem__(self, key: Any, value: Any) -> None: ...

    def __str__(self) -> str: ...

    def __sub__(self, value: object) -> ndarray[_Num]: ...

    def __truediv__(sel, value: object) -> ndarray[_Num]: ...

    def __xor__(self, value: object) -> ndarray[_Num]: ...

#
# numpy's scalar hierarchy (http://docs.scipy.org/doc/numpy/reference/arrays.scalars.html#scalars)
#

# Thomas: I'm not at all sure what this does
_Scalar = TypeVar('_Scalar')

class generic(Generic[_Scalar]): ...
class bool_(generic[bool]): ...
class number(generic[_Scalar], Generic[_Scalar]): ...
class integer(number[int]): ...
class signedinteger(integer): ...
class byte(signedinteger): ...
class short(signedinteger): ...
class intc(signedinteger): ...
class int_(signedinteger): ...
class longlong(signedinteger): ...
class int8(signedinteger): ...
class int16(signedinteger): ...
class int32(signedinteger): ...
class int64(signedinteger): ...
class unsignedinteger(integer): ...
class ubyte(unsignedinteger): ...
class ushort(unsignedinteger): ...
class uintc(unsignedinteger): ...
class uint(unsignedinteger): ...
class ulonglong(unsignedinteger): ...
class uint8(signedinteger): ...
class uint16(signedinteger): ...
class uint32(signedinteger): ...
class uint64(signedinteger): ...
class inexact(number[float]): ...
class floating(inexact): ...
class half(floating): ...
class single(floating): ...
class float_(floating): ...
class longfloat_(floating): ...
class float16(floating): ...
class float32(floating): ...
class float64(floating): ...
class float128(floating): ...
class complexfloating(inexact): ...
class csingle(complexfloating): ...
class complex_(complexfloating): ...
class clongfloat(complexfloating): ...
class complex64(complexfloating): ...
class complex128(complexfloating): ...
class complex256(complexfloating): ...
class flexible(generic[_Scalar], Generic[_Scalar]): ...
class character(flexible[str]): ...
class str_(character): ...
class unicode_(character): ...
class void(flexible[None]): ...

#
# Array creation routines
#

def array(object: Union[NestedList[_Num], ndarray[_Num]], dtype: _DtypeType = None) -> ndarray[_Num]: ...
def asarray(a: Any, dtype: _DtypeType=None, order: str=None) -> ndarray: ...
def ascontiguousarray(a: Any, dtype: _DtypeType=None) -> ndarray: ...
def copy(a: Any, order: str=None)	-> ndarray: ...
def empty(shape: _ShapeType, dtype: _DtypeType=float, order: str='C') -> ndarray: ...
def empty_like(a: Any, dtype: Any=None, order: str='K', subok: bool=True) -> ndarray: ...
def eye(N: int, M: int=None, k: int=0, dtype: _DtypeType=float) -> ndarray: ...
def full(shape: _ShapeType, fill_value: Any, dtype: _DtypeType=None,
         order: str='C') -> ndarray: ...
def full_like(a: Any, fill_value: Any, dtype: _DtypeType=None, order: str='C',
              subok: bool=True) -> ndarray: ...
# def fromfunction(function: Callable[..., _S], shape: _ShapeType, dtype: _DtypeType=float) -> ndarray[_S]: ...
def fromiter(iterable: Iterator, dytpe: _DtypeType, count: int=-1) -> ndarray: ...
def fromstring(string: str, dtype: _DtypeType=float, count: int=-1, sep: str='') -> ndarray: ...
def identity(n: int, dtype: _DtypeType=None) -> ndarray: ...
def load(file: Union[Path, IO]) -> ndarray: ...
def loadtxt(fname: Any, dtype: _DtypeType=float, comments: Union[str, Sequence[str]]='#',
            delimiter: str=None, converters: Dict[int, Callable[[Any], float]]=None,
            skiprows: int=0, usecols: Sequence[int]=None,
            unpack: bool=False, ndmin: int=0) -> ndarray: ...
def ones(shape: _ShapeType, dtype: Optional[_DtypeType]=..., order: str='C') -> ndarray: ...
def ones_like(a: Any, dtype: Any=None, order: str='K', subok: bool=True) -> ndarray: ...
def savetxt(fname: str, X: ndarray, header: str = None) -> None: ...
def savez(file: Path, *args: ndarray, **kwds: ndarray) -> None: ...
def zeros(shape: _ShapeType, dtype: _DtypeType=float, order: str='C') -> ndarray: ...
def zeros_like(a: Any, dtype: Any=None, order: str='K', subok: bool=True) -> ndarray: ...

#
# Transforming functions
#

def unique(a: ndarray[_Num]) -> ndarray[_Num]: ...
def where(a: ndarray[_Num]) -> ndarray[_Num]: ...
def astype(a: ndarray[_Num], dtype: _Num2) -> ndarray[_Num2]: ...

# reduction
def mean(a: ndarray, axis: _AxesType = None, keepdims: bool=False) -> ndarray[float]: ...
def sum(a: ndarray[_Num], axis: _AxesType = None, keepdims: bool=False) -> ndarray[_Num]: ...
def min(a: ndarray[_Num], axis: _AxesType = None, keepdims: bool=False) -> ndarray[_Num]: ...
def max(a: ndarray[_Num], axis: _AxesType = None, keepdims: bool=False) -> ndarray[_Num]: ...

def log(a: ndarray[_Num]) -> ndarray[_Num]: ...
def matmul(a: ndarray[_Num], b: ndarray[_Num]) -> ndarray[_Num]: ...
def expand_dims(a: ndarray[_Num], axis: _AxesType) -> ndarray[_Num]: ...
def diag(a: ndarray[_Num]) -> ndarray[_Num]: ...
def exp(a: ndarray[_Num]) -> ndarray[_Num]: ...
def trae(a: ndarray[_Num]) -> ndarray[_Num]: ...
def hstack(tup: Tuple[ndarray[_Num], ...]) -> ndarray[_Num]: ...
def ceil(a: ndarray[_Num]) -> ndarray[_Num]: ...
def arange(range_: int) -> ndarray[_Num]: ...
def trace(a: ndarray[_Num]) -> _Num: ...
def split(a: ndarray[_Num], split_dims: List[int]) -> List[ndarray[_Num]]: ...
def reshape(a: ndarray[_Num], newshape: _ShapeType) -> ndarray[_Num]: ...
def concatenate(an: Union[List[ndarray[_Num]], Tuple[ndarray[_Num], ...]], axis: _AxesType = 0) -> (
    ndarray[_Num]): ...
def sqrt(a: ndarray) -> ndarray[float]: ...
def power(x1: ndarray[_Num], x2: Union[_AnyNum, ndarray[_Num]]) -> ndarray[_Num]: ...


#
# weird classes
#
class matrix:
    def __init__(self, data: Union[List, str], dtype: _DtypeType = float, copy: bool = True): ...
    def reshape(self, shape: _ShapeType) -> matrix: ...

# Specific values
inf: float
nan: float
